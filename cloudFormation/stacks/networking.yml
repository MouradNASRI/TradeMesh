AWSTemplateFormatVersion: '2010-09-09'
Description: TradeMesh — Networking (VPC, subnets per tier, IGW, NAT, routes, endpoints)

Parameters:
  NamePrefix:        { Type: String, Default: trd }
  VpcCidr:           { Type: String, Default: 10.20.0.0/16 }
  Az1:               { Type: String, Default: us-east-1a }
  Az2:               { Type: String, Default: us-east-1b }
  Az3:               { Type: String, Default: us-east-1c }
  NatPerAz:          { Type: String, AllowedValues: [true,false], Default: false }

Conditions:
  UseNatPerAz: !Equals [!Ref NatPerAz, "true"]

Resources:

  # ---------------- VPC ----------------
  VPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: !Ref VpcCidr
      EnableDnsSupport: true      # name resolution inside VPC
      EnableDnsHostnames: true    # required for private DNS (endpoints), ALB, etc.
      Tags: [{ Key: Name, Value: !Sub '${NamePrefix}-vpc' }]

  IGW:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags: [{ Key: Name, Value: !Sub '${NamePrefix}-igw' }]

  VpcIgwAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      InternetGatewayId: !Ref IGW
      VpcId: !Ref VPC

  # ------------- Deterministic /20 subnets from the VPC CIDR -------------
  # Split the /16 into 20 subnets of /20 (cidrBits: 4). We then pick indexes per AZ + tier.
  # AZ1 uses indexes 0..4, AZ2 uses 5..9, AZ3 uses 10..14
  SubnetBlocks:
    Type: 'AWS::EC2::VPCCidrBlock'   # dummy placeholder? No — we’ll compute inline with Fn::Cidr; this logical is not needed
    Condition: !Equals [ "1", "0" ]  # never created (CFN requires a resource section above); ignore
  # Helper local list
  # (we'll inline Fn::Cidr where needed)

  # ---------------- Public subnets (MapPublicIpOnLaunch=true) ----------------
  PublicSubnetAz1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Ref Az1
      MapPublicIpOnLaunch: true
      CidrBlock: !Select [0, !Cidr [ !Ref VpcCidr, 20, 4 ]]
      Tags: [{ Key: Name, Value: !Sub '${NamePrefix}-public-a' }, { Key: Tier, Value: public }]

  PublicSubnetAz2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Ref Az2
      MapPublicIpOnLaunch: true
      CidrBlock: !Select [5, !Cidr [ !Ref VpcCidr, 20, 4 ]]
      Tags: [{ Key: Name, Value: !Sub '${NamePrefix}-public-b' }, { Key: Tier, Value: public }]

  PublicSubnetAz3:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Ref Az3
      MapPublicIpOnLaunch: true
      CidrBlock: !Select [10, !Cidr [ !Ref VpcCidr, 20, 4 ]]
      Tags: [{ Key: Name, Value: !Sub '${NamePrefix}-public-c' }, { Key: Tier, Value: public }]

  # ---------------- App subnets (private via NAT) ----------------
  AppSubnetAz1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Ref Az1
      CidrBlock: !Select [1, !Cidr [ !Ref VpcCidr, 20, 4 ]]
      Tags: [{ Key: Name, Value: !Sub '${NamePrefix}-app-a' }, { Key: Tier, Value: app }]

  AppSubnetAz2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Ref Az2
      CidrBlock: !Select [6, !Cidr [ !Ref VpcCidr, 20, 4 ]]
      Tags: [{ Key: Name, Value: !Sub '${NamePrefix}-app-b' }, { Key: Tier, Value: app }]

  AppSubnetAz3:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Ref Az3
      CidrBlock: !Select [11, !Cidr [ !Ref VpcCidr, 20, 4 ]]
      Tags: [{ Key: Name, Value: !Sub '${NamePrefix}-app-c' }, { Key: Tier, Value: app }]

  # ---------------- Data subnets (no outbound internet by default) ----------------
  DataSubnetAz1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Ref Az1
      CidrBlock: !Select [2, !Cidr [ !Ref VpcCidr, 20, 4 ]]
      Tags: [{ Key: Name, Value: !Sub '${NamePrefix}-data-a' }, { Key: Tier, Value: data }]

  DataSubnetAz2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Ref Az2
      CidrBlock: !Select [7, !Cidr [ !Ref VpcCidr, 20, 4 ]]
      Tags: [{ Key: Name, Value: !Sub '${NamePrefix}-data-b' }, { Key: Tier, Value: data }]

  DataSubnetAz3:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Ref Az3
      CidrBlock: !Select [12, !Cidr [ !Ref VpcCidr, 20, 4 ]]
      Tags: [{ Key: Name, Value: !Sub '${NamePrefix}-data-c' }, { Key: Tier, Value: data }]

  # ---------------- Endpoint subnets (for interface endpoints if you add them) ----------------
  EpSubnetAz1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Ref Az1
      CidrBlock: !Select [3, !Cidr [ !Ref VpcCidr, 20, 4 ]]
      Tags: [{ Key: Name, Value: !Sub '${NamePrefix}-ep-a' }, { Key: Tier, Value: endpoint }]

  EpSubnetAz2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Ref Az2
      CidrBlock: !Select [8, !Cidr [ !Ref VpcCidr, 20, 4 ]]
      Tags: [{ Key: Name, Value: !Sub '${NamePrefix}-ep-b' }, { Key: Tier, Value: endpoint }]

  EpSubnetAz3:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Ref Az3
      CidrBlock: !Select [13, !Cidr [ !Ref VpcCidr, 20, 4 ]]
      Tags: [{ Key: Name, Value: !Sub '${NamePrefix}-ep-c' }, { Key: Tier, Value: endpoint }]

  # ---------------- Analytics subnets (EMR/KDA/Flink, etc.) ----------------
  AnalyticsSubnetAz1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Ref Az1
      CidrBlock: !Select [4, !Cidr [ !Ref VpcCidr, 20, 4 ]]
      Tags: [{ Key: Name, Value: !Sub '${NamePrefix}-analytics-a' }, { Key: Tier, Value: analytics }]

  AnalyticsSubnetAz2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Ref Az2
      CidrBlock: !Select [9, !Cidr [ !Ref VpcCidr, 20, 4 ]]
      Tags: [{ Key: Name, Value: !Sub '${NamePrefix}-analytics-b' }, { Key: Tier, Value: analytics }]

  AnalyticsSubnetAz3:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Ref Az3
      CidrBlock: !Select [14, !Cidr [ !Ref VpcCidr, 20, 4 ]]
      Tags: [{ Key: Name, Value: !Sub '${NamePrefix}-analytics-c' }, { Key: Tier, Value: analytics }]

  # ---------------- Route tables ----------------
  PublicRT:
    Type: AWS::EC2::RouteTable
    Properties: { VpcId: !Ref VPC, Tags: [{ Key: Name, Value: !Sub '${NamePrefix}-public-rt' }] }

  PublicDefaultRoute:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref PublicRT
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref IGW
    DependsOn: VpcIgwAttachment

  PublicAssocA: { Type: AWS::EC2::SubnetRouteTableAssociation, Properties: { SubnetId: !Ref PublicSubnetAz1, RouteTableId: !Ref PublicRT } }
  PublicAssocB: { Type: AWS::EC2::SubnetRouteTableAssociation, Properties: { SubnetId: !Ref PublicSubnetAz2, RouteTableId: !Ref PublicRT } }
  PublicAssocC: { Type: AWS::EC2::SubnetRouteTableAssociation, Properties: { SubnetId: !Ref PublicSubnetAz3, RouteTableId: !Ref PublicRT } }

  # NAT(s): 1 shared (cost saver) or 1 per AZ (HA)
  NatEipA: { Type: AWS::EC2::EIP, Condition: UseNatPerAz, Properties: { Domain: vpc } }
  NatA:
    Type: AWS::EC2::NatGateway
    Condition: UseNatPerAz
    Properties:
      AllocationId: !GetAtt NatEipA.AllocationId
      SubnetId: !Ref PublicSubnetAz1
      Tags: [{ Key: Name, Value: !Sub '${NamePrefix}-nat-a' }]

  NatEipB: { Type: AWS::EC2::EIP, Condition: UseNatPerAz, Properties: { Domain: vpc } }
  NatB:
    Type: AWS::EC2::NatGateway
    Condition: UseNatPerAz
    Properties:
      AllocationId: !GetAtt NatEipB.AllocationId
      SubnetId: !Ref PublicSubnetAz2
      Tags: [{ Key: Name, Value: !Sub '${NamePrefix}-nat-b' }]

  NatEipC: { Type: AWS::EC2::EIP, Condition: UseNatPerAz, Properties: { Domain: vpc } }
  NatC:
    Type: AWS::EC2::NatGateway
    Condition: UseNatPerAz
    Properties:
      AllocationId: !GetAtt NatEipC.AllocationId
      SubnetId: !Ref PublicSubnetAz3
      Tags: [{ Key: Name, Value: !Sub '${NamePrefix}-nat-c' }]

  # Single-NAT pattern (dev cost saver)
  NatEipSingle: { Type: AWS::EC2::EIP, Condition: !Not [ !Equals [ !Ref NatPerAz, "true" ] ], Properties: { Domain: vpc } }
  NatSingle:
    Type: AWS::EC2::NatGateway
    Condition: !Not [ !Equals [ !Ref NatPerAz, "true" ] ]
    Properties:
      AllocationId: !GetAtt NatEipSingle.AllocationId
      SubnetId: !Ref PublicSubnetAz1
      Tags: [{ Key: Name, Value: !Sub '${NamePrefix}-nat' }]

  # Private route tables per AZ (app & analytics share; data uses same unless you want no-NAT)
  PrivateRTA: { Type: AWS::EC2::RouteTable, Properties: { VpcId: !Ref VPC, Tags: [{ Key: Name, Value: !Sub '${NamePrefix}-priv-a' }] } }
  PrivateRTB: { Type: AWS::EC2::RouteTable, Properties: { VpcId: !Ref VPC, Tags: [{ Key: Name, Value: !Sub '${NamePrefix}-priv-b' }] } }
  PrivateRTC: { Type: AWS::EC2::RouteTable, Properties: { VpcId: !Ref VPC, Tags: [{ Key: Name, Value: !Sub '${NamePrefix}-priv-c' }] } }

  PrivateDefaultA:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref PrivateRTA
      DestinationCidrBlock: 0.0.0.0/0
      NatGatewayId: !If [ UseNatPerAz, !Ref NatA, !Ref NatSingle ]

  PrivateDefaultB:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref PrivateRTB
      DestinationCidrBlock: 0.0.0.0/0
      NatGatewayId: !If [ UseNatPerAz, !Ref NatB, !Ref NatSingle ]

  PrivateDefaultC:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref PrivateRTC
      DestinationCidrBlock: 0.0.0.0/0
      NatGatewayId: !If [ UseNatPerAz, !Ref NatC, !Ref NatSingle ]

  # Associate app+analytics subnets to private RTs (data can share; tighten later if needed)
  AppAssocA: { Type: AWS::EC2::SubnetRouteTableAssociation, Properties: { SubnetId: !Ref AppSubnetAz1, RouteTableId: !Ref PrivateRTA } }
  AppAssocB: { Type: AWS::EC2::SubnetRouteTableAssociation, Properties: { SubnetId: !Ref AppSubnetAz2, RouteTableId: !Ref PrivateRTB } }
  AppAssocC: { Type: AWS::EC2::SubnetRouteTableAssociation, Properties: { SubnetId: !Ref AppSubnetAz3, RouteTableId: !Ref PrivateRTC } }

  AnalyticsAssocA: { Type: AWS::EC2::SubnetRouteTableAssociation, Properties: { SubnetId: !Ref AnalyticsSubnetAz1, RouteTableId: !Ref PrivateRTA } }
  AnalyticsAssocB: { Type: AWS::EC2::SubnetRouteTableAssociation, Properties: { SubnetId: !Ref AnalyticsSubnetAz2, RouteTableId: !Ref PrivateRTB } }
  AnalyticsAssocC: { Type: AWS::EC2::SubnetRouteTableAssociation, Properties: { SubnetId: !Ref AnalyticsSubnetAz3, RouteTableId: !Ref PrivateRTC } }

  DataAssocA: { Type: AWS::EC2::SubnetRouteTableAssociation, Properties: { SubnetId: !Ref DataSubnetAz1, RouteTableId: !Ref PrivateRTA } }
  DataAssocB: { Type: AWS::EC2::SubnetRouteTableAssociation, Properties: { SubnetId: !Ref DataSubnetAz2, RouteTableId: !Ref PrivateRTB } }
  DataAssocC: { Type: AWS::EC2::SubnetRouteTableAssociation, Properties: { SubnetId: !Ref DataSubnetAz3, RouteTableId: !Ref PrivateRTC } }

  # --------- Gateway Endpoints (free) for S3 & DynamoDB (private RTs) ---------
  S3GatewayEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      VpcId: !Ref VPC
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.s3'
      RouteTableIds: [ !Ref PrivateRTA, !Ref PrivateRTB, !Ref PrivateRTC ]
      VpcEndpointType: Gateway

  DdbGatewayEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      VpcId: !Ref VPC
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.dynamodb'
      RouteTableIds: [ !Ref PrivateRTA, !Ref PrivateRTB, !Ref PrivateRTC ]
      VpcEndpointType: Gateway

Outputs:
  VpcId:                    { Value: !Ref VPC }
  PublicSubnets:            { Value: !Join [',', [ !Ref PublicSubnetAz1, !Ref PublicSubnetAz2, !Ref PublicSubnetAz3 ]] }
  AppSubnets:               { Value: !Join [',', [ !Ref AppSubnetAz1, !Ref AppSubnetAz2, !Ref AppSubnetAz3 ]] }
  DataSubnets:              { Value: !Join [',', [ !Ref DataSubnetAz1, !Ref DataSubnetAz2, !Ref DataSubnetAz3 ]] }
  EndpointSubnets:          { Value: !Join [',', [ !Ref EpSubnetAz1, !Ref EpSubnetAz2, !Ref EpSubnetAz3 ]] }
  AnalyticsSubnets:         { Value: !Join [',', [ !Ref AnalyticsSubnetAz1, !Ref AnalyticsSubnetAz2, !Ref AnalyticsSubnetAz3 ]] }
